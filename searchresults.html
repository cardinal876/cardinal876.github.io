<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>edwinbook search</title>

<link rel="stylesheet" href="header.css"> <!-- NEW: CSS loads before JS -->
 <script src="data.js"></script>
<script src="fields.json"></script>
  

  
  <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link
  href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;700;800;900&display=swap"
  rel="stylesheet"
/>

  
  
<style>
:root {
  --bg-color: #ffffff;
  --text-color: #111111;
  --accent-color: #10a37f;
  --border-color: #e2e2e2;
  --input-bg: #f9f9f9;
}

* { box-sizing: border-box; }

body {
    visibility:hidden;
  margin: 0;
  padding: 0;
  
  background-color: var(--bg-color);
  color: var(--text-color);
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}





/* RESULTS */
.no-results{
    margin-top: 1rem 
}




.results {
  width: 100%;
  max-width: 800px;
  padding: 1rem 1.5rem;
  margin: 0 auto;
  box-sizing: border-box;
  flex: 1;
    flex-grow: 1; /* Makes the results section grow and fill available space */
    border-bottom: 1px solid var(--border-color);
}

.result-link {
  display: block;
  text-decoration: none;
  color: inherit;
  
  padding: 1rem 0;
  transition: background-color 0.2s ease;
}

.result-title {
  font-size: 1.25rem;
  font-weight: 400; 
  color: #1a0dab;    
  margin: 0;
  text-decoration: none;
  width: fit-content; 
}

.result-title:hover { text-decoration: underline; }
.result-link:hover { background-color: #f5f5f5; }

.author { font-size: 0.9rem; color: #666; margin-top: 0.25rem;}
.snippet { margin-top: 0.5rem; font-size: 1rem; color: #333; }

footer {
  text-align: center;
  padding: 1rem;
  font-size: 0.9rem;
  color: #888;
  border-top: 1px solid var(--border-color);
  width: 100%;
  margin-top:auto;
  bottom: -100px;  /* Position the footer below the viewport initially */

}



.pagination button {
  margin: 0 4px;
  padding: 5px 10px;
  border: none; /* Remove border from all buttons */
  background-color: transparent; /* Default background */
  cursor: pointer;
  border-radius: 0;
  transition: background-color 0.2s ease;
  
}
.pagination button:hover:not(:disabled) {
  background-color: #f0f0f0;
}
.pagination button:disabled {
  opacity: 0.5;
  cursor: default;
}





.pagination{
    
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    
}

.pagination {
  
  text-align: center;
 /* line-height: 2.5; /* Adds vertical breathing room between lines */
  display: flex;
  flex-wrap: wrap; /* Allow wrapping on smaller screens */
  justify-content: center;
  gap: .25rem; /* Adds horizontal and vertical space between buttons */
row-gap: 1.0rem;
    
}







/* Highlight selected page button */
.pagination button.selected {
  background-color: #1a3faa;
  color: white;
}


hr {
  border: none;
  border-top: 1px solid lightgray;
  width: 100%;
  margin: 0; /* optional spacing */
}







</style>


  <style>
  
  .results-top{
   /* border: 1px solid green;*/
    
      display: flex;
      
      
  
 ;
      max-width: 800px;
      width: 100%;
      padding: 2rem 1.5rem;
     margin: 0 auto;
     
  
  
  
  
  width: 100%;
  max-width: 800px;
  padding: 2rem 1.5rem;
  padding-top: 1rem;
  padding-bottom: 0;
  
  box-sizing: border-box;
  font-weight: bold;
  color:lightgray;
  gap: 1.5rem;
 
  
 /* flex: 1;
    flex-grow: 1;  Makes the results section grow and fill available space */
      overflow-x: auto;  /* enable horizontal scroll */
  overflow-y: hidden; /* hide vertical overflow */
  scroll-behavior: smooth; /* optional: smooth horizontal scrolling */
  -webkit-overflow-scrolling: touch; /* smooth scroll for mobile */
  
    /* Hide scrollbar — cross-browser */
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */



  






    
    
    
    
}


/* Hide scrollbar — Chrome, Safari, Opera */
.results-top::-webkit-scrollbar {
  display: none;
}
   


.results-top div{
  /*  border: 1px blue solid; */
}






  /* Scrollable row */
  .scroll-row {
    display: flex;
    overflow-x: auto;
    white-space: nowrap;
    
    

  }

  .menu-btn {
    border: none;

    cursor: pointer;
    
  }

  .menu-btn:hover {
    
  }

  /* Dropdowns (outside scroll area) */
  .dropdown {
    position: absolute;
    display: none;
    background: white;
    border: 1px solid #ccc;
    ;
    z-index: 1000;
  }

  .dropdown div {
    padding: 0.5rem 1rem;
    cursor: pointer;
  }

  .dropdown div:hover {

  }
  
  
  
  html, header, body, footer, input::placeholder{
    
    
  font-family: 'Source Sans Pro', sans-serif;



  
}

</style> 



<script src="https://cdn.jsdelivr.net/npm/flexsearch@0.7.31/dist/flexsearch.bundle.js"></script>
</head>
<body>

 <header id="header-container"></header>

 



<div class="results-top scroll-row">
     <div class="menu-btn" data-menu="1">Sort  </div> 
        
           <div class="menu-btn" data-menu="2">Type </div>  

    <div class="menu-btn" data-menu="4">Author</div>  
  
  
     <div id="fields-button-one"  data-menu="7">Field</div>  
        
      <div class="menu-btn" data-menu="6">Date </div> 
                   <div class="menu-btn" data-menu="3" >Region</div> 
    
 <!-- <div class="menu-btn" data-menu="1">Menu 1</div> -->


</div> 

<div class="dropdown" id="dropdown-1">
  <div>Publish Date</div>
  <div>Views</div>
  <div>Relevance</div>
</div>

<div class="dropdown" id="dropdown-2" >
    <div>Event</div>
      <div >Biography</div>
          <div >Thing</div>
      <div >Place</div>
      
         <div >Concept</div>
      <div >Other</div>
      
      
</div>



<div class="dropdown" id="dropdown-3">

      <div >North America</div>
      <div>South America</div>
            <div >Africa</div>
      <div >Europe</div>
            <div >Asia</div>
      <div>Oceania</div>
            <div>Antarctica</div>
</div>

<div class="dropdown" id="dropdown-4">
  <div>Helvetica</div>
  <div>Times</div>
  <div>Roboto</div>
</div>

<div class="dropdown" id="dropdown-5">


      <div >Science</div>
      <div >History</div>
      <div >Art</div>
        <div >Technology</div>
          <div >Other</div>
</div>

<div class="dropdown" id="dropdown-6">
        <div >Before 0CE</div>
      <div >0 CE to 1000 CE</div>
      <div>1000 CE to 2000 CE</div>
      <div>2000 to Present</div>
</div>












<div id="results"></div> <!-- search results will appear here -->








<footer id="footer-container"></footer>


  
  <script>

      
      let flatResults;
  let currentPage;
  let firstLoad;
  let renderPage; 
  
  // Filtered subset of flatResults
let filteredResults = [];
let useFilter =false;


    
    // Create FlexSearch index
const index = new FlexSearch.Document({
  document: {
    id: "id",
    index: ["combined"], // only search this field
    store: ["id", "title", "content", "date","region", "type", "field", "author","description2", "url"] // keep others for displaying
  }
});

// Add documents from external JS
if (typeof documents !== 'undefined' && Array.isArray(documents)) {
  documents.forEach(doc => {
    index.add({
      id: doc.id,
      combined: `${doc.title} ${doc.content} ${doc.field} ${doc.description2} ${doc.url || ''}`, // merged searchable text
      title: doc.title,
      author: doc.author,
      content: doc.content,
      field: doc.field,
      date:doc.date,
      region:doc.region,
      type:doc.type,
      url: doc.url,
      description2: doc.description2
    });
  });
} else {
  console.error("No documents found in data.js");
}

    


    // Add docs to index
  //  documents.forEach(doc => index.add(doc));

    // Load header.html dynamically
    document.addEventListener('DOMContentLoaded', () => {
      const xhr = new XMLHttpRequest();
      xhr.open('GET', 'header.html', true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && (xhr.status === 200 || xhr.status == 0)) {
          document.getElementById('header-container').innerHTML = xhr.responseText;

          // Menu toggle logic (optional)
          const menuButton = document.getElementById("menuToggle");
          const menuDropdown = document.getElementById("menuDropdown");
          if (menuButton && menuDropdown) {
            menuButton.addEventListener("click", () => {
              menuDropdown.style.display =
                menuDropdown.style.display === "flex" ? "none" : "flex";
            });
            document.addEventListener("click", (e) => {
              if (!menuButton.contains(e.target) && !menuDropdown.contains(e.target)) {
                menuDropdown.style.display = "none";
              }
            });
          }

          // Attach search logic
          const searchForm = document.getElementById('searchForm');
          const searchInput = document.getElementById('searchInput');
          const resultsContainer = document.getElementById('results');

          if (searchForm && searchInput && resultsContainer) {
            searchForm.addEventListener('submit', (e) => {
              e.preventDefault();
              const query = searchInput.value.trim();
              
              
              
              
              



if (!query) {
  // No search term — show all documents
  flatResults = documents.map(doc => ({
    id: doc.id,
    title: doc.title,
    content: doc.content,
    field: doc.field,
    date:doc.date,
      region:doc.region,
      type:doc.type,
    url: doc.url,
    author: doc.author,
    description2: doc.description2
  }));
} else {

const searchResults = index.search(query, { enrich: true, limit: 100 });





              // Flatten results because it's returned by field
              

const seen = new Set();
flatResults = [];




searchResults.forEach(fieldResult => {
  fieldResult.result.forEach(r => {
      
    if (!seen.has(r.doc.id)) {
      seen.add(r.doc.id);
      flatResults.push(r.doc);
    }
  });
});


}

              
              



if (flatResults.length === 0) {
  // Create a "No results" placeholder
  const noResultsEntry = {
    id: "no-results",
    title: "No results",
    author: "View all",
    description2: "Other results:",
    content: "",
    field: "",
    url: "#"
  };

  // Then append all documents as fallback "browse all" entries
  const allDocs = (typeof documents !== "undefined")
    ? documents.map(doc => ({
        id: doc.id,
        title: doc.title,
        author: doc.author,
        description2: doc.description2,
        content: doc.content,
        field: doc.field,
        date:doc.date,
      region:doc.region,
      type:doc.type,
        url: doc.url
      }))
    : [];

  // Merge the two — no-results first
  flatResults = [noResultsEntry, ...allDocs];
}










  const RESULTS_PER_PAGE = 4;
  currentPage = 1;
  
  firstLoad = true;

  // Helper: render results for a specific page
 
  renderPage =  function (page, skipHistory = false) {
      
      
      console.log("render called")
      console.log(filteredResults.length)
     
    let activeResults = flatResults; 
     
     if (useFilter){
         console.log("use filter ")
         activeResults = filteredResults;
         useFilter= false;
     }
      
    
    console.log(filteredResults.length)

    const start = (page - 1) * RESULTS_PER_PAGE;
    const end = start + RESULTS_PER_PAGE;
    const pageResults = activeResults.slice(start, end);

    const WORDS_TO_SHOW = 30;
    const htmlResults = pageResults.map(r => {
      const words = r.content.split(/\s+/).slice(0, WORDS_TO_SHOW).join(' ');
      const more = r.content.split(/\s+/).length > WORDS_TO_SHOW ? "..." : "";
      var toReturn;
      if( r.id==="no-results"){
      toReturn= `
        <div class="results">
       
            <h3 class="no-results" style="margin-top: 2rem; font-weight:normal">No Results</h3>
            
     <a href="searchresults.html" style="text-decoration:none;display:block;margin-top: 5rem ;margin-bottom: 1em; color:gray">
  <h3 class="no-results" style="
    display: inline-flex;
    align-items: center;
    gap: 0.2em;
    margin: 0;
    font-weight: normal; 
  ">
    <img src="open-svgrepo.svg" alt="Open Book" style="height:1.25em;" />
    View All
  </h3>
</a>
  <a href="searchresults.html" style="text-decoration:none;display:block; margin-bottom: 1em; color: gray">
  <h3 class="no-results" style="
    display: inline-flex;
    align-items: center;
    gap: 0.2em;
    margin: 0;
    font-weight: normal; 
  ">
    <img src="newcircle-svgrepo.svg" alt="New sticker" style="height:1.25em;" />
    New Articles: 
  </h3>
</a>
                  
        
          
        </div>
      `;}else{
      toReturn=`
        <div class="results">
          <a href="${r.url}" class="result-link">
            <h2 class="result-title">${r.title}</h2>
            <div class="author">${r.author}</div>
            <div class="snippet">${words}${more}</div>
          </a>
        </div>
      `;}
     return toReturn;
    }).join('');

    // Pagination buttons
    const totalPages = Math.ceil(activeResults.length / RESULTS_PER_PAGE);
    let paginationHTML = `<div class="pagination" style="text-align:center; margin-top:1rem;">`;

    // Prev button

paginationHTML += `<button ${page === 1 ? 'disabled' : ''} data-page="${page - 1}">Prev</button>`;


    // Page numbers (show up to 7 pages centered around current)
    const maxVisible = 5;
    const startPage = Math.max(1, page - Math.floor(maxVisible / 2));
    const endPage = Math.min(totalPages, startPage + maxVisible - 1);

    for (let i = startPage; i <= endPage; i++) {
      paginationHTML += `<button data-page="${i}" ${i === page ? 'style="background-color:#999999;color:white;border:none;padding:5px 10px;border-radius:4px;"' : ''}>${i}</button>`;
    }

    // Next button
    paginationHTML += `<button ${page === totalPages ? 'disabled' : ''} data-page="${page + 1}">Next</button>`;
    paginationHTML += `</div>`;

    resultsContainer.innerHTML = htmlResults + paginationHTML;
    


  if (!skipHistory && !firstLoad) {
    const newUrl = window.location.pathname + "?q=" + encodeURIComponent(searchInput.value.trim()) + (page > 1 ? `&page=${page}` : '');
    history.pushState({ page }, "", newUrl);
  }
  firstLoad = false;

    // Attach button click handlers
    resultsContainer.querySelectorAll('.pagination button[data-page]').forEach(btn => {
      btn.addEventListener('click', () => {
        const newPage = parseInt(btn.dataset.page);
        if (newPage >= 1 && newPage <= totalPages && newPage !== currentPage) {
          currentPage = newPage;
          renderPage(currentPage);
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
      });
    });
  }

  // Initial render
 renderPage(currentPage);


// Handle browser back/forward within pagination
window.addEventListener("popstate", (event) => {
  const page = event.state?.page || 1;
  currentPage = page;
  renderPage(currentPage, true);
});




              
      
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
            });
        
            
            
            // --- Auto-run search if ?q= is present in the URL ---
const urlParams = new URLSearchParams(window.location.search);
const queryFromURL = urlParams.get('q');

if (queryFromURL !== null) {   // <-- important: empty string is valid
  searchInput.value = queryFromURL;
  
}else{
    searchInput.value = "";
}
searchForm.dispatchEvent(new Event('submit'));


            
            
            
          }

          document.body.style.visibility = 'visible';
        } else if (xhr.readyState === 4) {
          console.error('Failed to load header.html');
        }
      };
      xhr.send();
      
      
            const xhr2 = new XMLHttpRequest();
      xhr2.open('GET', 'footer.html', true); // relative path to header.html
      xhr2.onreadystatechange = function() {
        if (xhr2.readyState === 4) {
          if (xhr2.status === 200 || xhr2.status == 0) { // 0 works for some local servers
            document.getElementById('footer-container').innerHTML = xhr2.responseText;

    }}}
        
        
     xhr2.send();   
      
      
      
      
      
      
    });


  </script>
  
  <script>
      
      
      
//// --- MENU FILTER BUTTONS CODE --- ////

const buttons = document.querySelectorAll(".menu-btn");
let openMenu = null;

// Track active filters (excluding author + field)
const activeFilters = {
  type: null,
  region: null,
  date: null,
  sort: null
};


// Helper: Date range logic
function dateMatchesFilter(dateStr, filter) {
  if (!dateStr) return false;
  const year = parseInt(dateStr.match(/-?\d+/)?.[0]) || 0;
  if (filter === "Before 0CE") return year < 0;
  if (filter === "0 CE to 1000 CE") return year >= 0 && year <= 1000;
  if (filter === "1000 CE to 2000 CE") return year > 1000 && year <= 2000;
  if (filter === "2000 to Present") return year > 2000;
  return true;
}

// Apply filters to current flatResults and re-render
function applyFilters() {
  if (!flatResults) return;

  filteredResults = flatResults.filter(doc => {
      
      
   console.log("filt " + activeFilters.type)   
      
    return (!activeFilters.type || doc.type.toLowerCase() === activeFilters.type.toLowerCase())
        && (!activeFilters.region || doc.region.toLowerCase() === activeFilters.region.toLowerCase())
        && (!activeFilters.date || dateMatchesFilter(doc.date.toLowerCase(), activeFilters.date.toLowerCase()));
  });

  // Sorting
  if (activeFilters.sort === "Publish Date") {
    filteredResults.sort((a, b) => (b.date || "").localeCompare(a.date || ""));
  } else if (activeFilters.sort === "Views") {
    filteredResults.sort((a, b) => (b.views || 0) - (a.views || 0));
  } // Relevance = keep natural order


if(activeFilters.type || activeFilters.region || activeFilters.date){

useFilter =true;

}


  renderPage(1);
}

// Main dropdown logic
buttons.forEach(btn => {
  btn.addEventListener("click", e => {

    // Skip author / field menus
    if (btn.dataset.menu === "4" || btn.dataset.menu === "7") return;

    const menu = document.getElementById("dropdown-" + btn.dataset.menu);
    const rect = btn.getBoundingClientRect();

    // Close previously open dropdown
    if (openMenu && openMenu !== menu) openMenu.style.display = "none";

    // Toggle dropdown visibility
    if (menu.style.display === "block") {
      menu.style.display = "none";
      openMenu = null;
      return;
    }

    menu.style.display = "block";
    menu.style.top = rect.bottom + "px";

    const menuWidth = menu.offsetWidth;
    const viewportWidth = window.innerWidth;
    let leftPos = rect.left;
    if (rect.left + menuWidth > viewportWidth) leftPos = viewportWidth - menuWidth;
    if (leftPos < 0) leftPos = 0;
    menu.style.left = leftPos + "px";

    // Add Clear option if already selected
    if (btn.dataset.selected === "true") {
      if (!menu.querySelector(".clear-option")) {
        const clearDiv = document.createElement("div");
        clearDiv.textContent = "Clear";
        clearDiv.classList.add("clear-option");
        clearDiv.style.color = "";
        menu.prepend(clearDiv);

        clearDiv.addEventListener("click", () => {
          btn.style.color = "lightgray";
          btn.dataset.selected = "false";
          clearDiv.remove();
          menu.style.display = "none";

          // Reset correct filter field
          if (btn.dataset.menu === "1") activeFilters.sort = null;
          if (btn.dataset.menu === "2") activeFilters.type = null;
          if (btn.dataset.menu === "3") activeFilters.region = null;
          if (btn.dataset.menu === "6") activeFilters.date = null;

          applyFilters();
        });
      }
    }

    // Handle each option click
    menu.querySelectorAll("div").forEach(option => {
      if (!option.classList.contains("clear-option")) {
        option.onclick = () => {
          btn.style.color = "black";
          btn.dataset.selected = "true";
          menu.style.display = "none";

          // Update activeFilters by menu type
          if (btn.dataset.menu === "1") activeFilters.sort = option.textContent.trim();
          if (btn.dataset.menu === "2") activeFilters.type = option.textContent.trim();
          if (btn.dataset.menu === "3") activeFilters.region = option.textContent.trim();
          if (btn.dataset.menu === "6") activeFilters.date = option.textContent.trim();

          applyFilters();
        };
      }
    });

    openMenu = menu;
  });
});

// Close dropdown when clicking outside
document.addEventListener("click", e => {
  const anyOpenDropdown = [...document.querySelectorAll(".dropdown")]
    .some(d => d.style.display === "block");

  if (anyOpenDropdown && !e.target.closest(".results-top") && !e.target.closest(".dropdown")) {
    document.querySelectorAll(".dropdown").forEach(d => d.style.display = "none");
    openMenu = null;
    e.stopPropagation();
    e.preventDefault();
  }
}, true);


      
   /// menu button code   
      
      /*
const buttons = document.querySelectorAll(".menu-btn");
let openMenu = null;

buttons.forEach(btn => {
  btn.addEventListener("click", e => {
      
      if(btn.dataset.menu ==="4"){
          return;
      }
      
    const menu = document.getElementById("dropdown-" + btn.dataset.menu);
    const rect = btn.getBoundingClientRect();

    // Close previously open dropdown
    if (openMenu && openMenu !== menu) openMenu.style.display = "none";

    // Toggle dropdown
    if (menu.style.display === "block") {
      menu.style.display = "none";
      openMenu = null;
      return;
    }

    menu.style.display = "block";
    menu.style.top = rect.bottom + "px";

    const menuWidth = menu.offsetWidth;
    const viewportWidth = window.innerWidth;

    let leftPos = rect.left;
    if (rect.left + menuWidth > viewportWidth) leftPos = viewportWidth - menuWidth;
    if (leftPos < 0) leftPos = 0;
    menu.style.left = leftPos + "px";

    // Skip selection/clear logic for Share menu

        
      // Add "Clear" option if already selected
      if (btn.dataset.selected === "true") {
        if (!menu.querySelector(".clear-option")) {
          const clearDiv = document.createElement("div");
          clearDiv.textContent = "Clear";
          clearDiv.classList.add("clear-option");
          clearDiv.style.color = ""; // gray
          menu.prepend(clearDiv);

          clearDiv.addEventListener("click", () => {
            btn.style.color = "lightgray";
            btn.dataset.selected = "false";
            clearDiv.remove();
            menu.style.display = "none";
          });
        }
      }

      // Attach click handler to options
      menu.querySelectorAll("div").forEach(option => {
        if (!option.classList.contains("clear-option")) {
          option.onclick = () => {
            btn.style.color = "black";
            btn.dataset.selected = "true";
            menu.style.display = "none";
          };
        }
      });
    

    openMenu = menu;
  });
});

document.addEventListener("click", e => {
  const anyOpenDropdown = [...document.querySelectorAll(".dropdown")]
    .some(d => d.style.display === "block");

  if (anyOpenDropdown && !e.target.closest(".results-top") && !e.target.closest(".dropdown")) {
    document.querySelectorAll(".dropdown").forEach(d => d.style.display = "none");
    openMenu = null;

    // Prevent the click **only if we actually closed a menu**
    e.stopPropagation();
    e.preventDefault(); 
  }
}, true); // capture phase ensures we intercept first

*/
</script>

<script>
    
    
document.addEventListener("DOMContentLoaded", () => {
  const authorBtn = document.querySelector('[data-menu="4"]');
  if (!authorBtn) return;

  const popup = document.createElement("div");
  popup.id = "dropdown-4";
  popup.className = "dropdown";
  Object.assign(popup.style, {
    padding: "0.75rem",
    position: "absolute",
    display: "none",
    background: "white",
    border: "1px solid #ccc",
    borderRadius: "10px",
    boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
    zIndex: "2000",
  });

  popup.innerHTML = `
    <input
      type="text"
      id="authorInput"
      placeholder="Type author name..."
      style="width:100%;padding:0.5rem;border:1px solid #ccc;border-radius:6px;"
    />
    <div id="authorSuggestions" style="
      border:1px solid #eee;
      border-radius:6px;
      margin-top:0.5rem;
      max-height:120px;
      overflow-y:auto;
      display:none;
    "></div>
    <div style="margin-top:0.75rem;text-align:right;">
      <button id="authorEnter" style="
        background:#007bff;
        color:white;
        border:none;
        padding:0.4rem 0.8rem;
        border-radius:6px;
        cursor:pointer;
        margin-right:0.5rem;
      ">Enter</button>
      <button id="authorClear" style="
        background:#eee;
        border:none;
        padding:0.4rem 0.8rem;
        border-radius:6px;
        cursor:pointer;
      ">Clear</button>
    </div>
  `;
  document.body.appendChild(popup);

  const authorInput = popup.querySelector("#authorInput");
  const authorSuggestions = popup.querySelector("#authorSuggestions");
  const authorEnter = popup.querySelector("#authorEnter");
  const authorClear = popup.querySelector("#authorClear");

  const authors = (typeof documents !== "undefined")
    ? [...new Set(documents.map(d => d.author).filter(a => a))].sort()
    : [];

  function positionPopup() {
    const rect = authorBtn.getBoundingClientRect();
    popup.style.top = rect.bottom + window.scrollY + "px";
    popup.style.left = rect.left + window.scrollX + "px";
  }

  function updateAuthorButtonColor() {
    const hasAuthor = authorInput.value.trim().length > 0;
    authorBtn.style.color = hasAuthor ? "black" : "lightgray";
  }

  authorBtn.addEventListener("click", e => {
    e.stopPropagation();
    const visible = popup.style.display === "block";
    document.querySelectorAll(".dropdown").forEach(d => d.style.display = "none");
    if (!visible) {
      positionPopup();
      popup.style.display = "block";
      authorInput.focus();
    } else {
      popup.style.display = "none";
      updateAuthorButtonColor();
    }
  });

  authorInput.addEventListener("input", () => {
    const val = authorInput.value.toLowerCase();
    const matches = authors.filter(a => a.toLowerCase().includes(val)).slice(0, 10);
    if (!val || matches.length === 0) {
      authorSuggestions.style.display = "none";
      updateAuthorButtonColor();
      return;
    }
    authorSuggestions.innerHTML = matches
      .map(a => `<div style="padding:0.4rem;cursor:pointer;">${a}</div>`)
      .join("");
    authorSuggestions.style.display = "block";

    authorSuggestions.querySelectorAll("div").forEach(div => {
      div.addEventListener("click", () => {
        authorInput.value = div.textContent;
        authorSuggestions.style.display = "none";
        updateAuthorButtonColor();
      });
    });
  });

  authorEnter.addEventListener("click", () => {
    updateAuthorButtonColor();
    popup.style.display = "none";
  });

  authorClear.addEventListener("click", () => {
    authorInput.value = "";
    authorSuggestions.style.display = "none";
    updateAuthorButtonColor();
  });

  // Click outside — close popup but prevent underlying clicks
  document.addEventListener("click", e => {
    if (!popup.contains(e.target) && !authorBtn.contains(e.target)) {
      if (popup.style.display === "block") {
        popup.style.display = "none";
        updateAuthorButtonColor();
        e.stopPropagation();
        e.preventDefault();
      }
    }
  }, true); // capture phase ensures we intercept first

  window.addEventListener("scroll", () => { if (popup.style.display === "block") positionPopup(); });
  window.addEventListener("resize", () => { if (popup.style.display === "block") positionPopup(); });
}); 
</script>
  <script>
    
    
document.addEventListener("DOMContentLoaded", () => {
  const authorBtn = document.querySelector('[data-menu="4"]');
  if (!authorBtn) return;

  const popup = document.createElement("div");
  popup.id = "dropdown-4";
  popup.className = "dropdown";
  Object.assign(popup.style, {
    padding: "0.75rem",
    position: "absolute",
    display: "none",
    background: "white",
    border: "1px solid #ccc",
    borderRadius: "10px",
    boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
    zIndex: "2000",
  });

  popup.innerHTML = `
    <input
      type="text"
      id="authorInput"
      placeholder="Type field name..."
      style="width:100%;padding:0.5rem;border:1px solid #ccc;border-radius:6px;"
    />
    <div id="authorSuggestions" style="
      border:1px solid #eee;
      border-radius:6px;
      margin-top:0.5rem;
      max-height:120px;
      overflow-y:auto;
      display:none;
    "></div>
    <div style="margin-top:0.75rem;text-align:right;">
      <button id="authorEnter" style="
        background:#007bff;
        color:white;
        border:none;
        padding:0.4rem 0.8rem;
        border-radius:6px;
        cursor:pointer;
        margin-right:0.5rem;
      ">Enter</button>
      <button id="authorClear" style="
        background:#eee;
        border:none;
        padding:0.4rem 0.8rem;
        border-radius:6px;
        cursor:pointer;
      ">Clear</button>
    </div>
  `;
  document.body.appendChild(popup);

  const authorInput = popup.querySelector("#authorInput");
  const authorSuggestions = popup.querySelector("#authorSuggestions");
  const authorEnter = popup.querySelector("#authorEnter");
  const authorClear = popup.querySelector("#authorClear");

  const authors = (typeof documents !== "undefined")
    ? [...new Set(documents.map(d => d.author).filter(a => a))].sort()
    : [];

  function positionPopup() {
    const rect = authorBtn.getBoundingClientRect();
    popup.style.top = rect.bottom + window.scrollY + "px";
    popup.style.left = rect.left + window.scrollX + "px";
  }

  function updateAuthorButtonColor() {
    const hasAuthor = authorInput.value.trim().length > 0;
    authorBtn.style.color = hasAuthor ? "black" : "lightgray";
  }

  authorBtn.addEventListener("click", e => {
    e.stopPropagation();
    const visible = popup.style.display === "block";
    document.querySelectorAll(".dropdown").forEach(d => d.style.display = "none");
    if (!visible) {
      positionPopup();
      popup.style.display = "block";
      authorInput.focus();
    } else {
      popup.style.display = "none";
      updateAuthorButtonColor();
    }
  });

  authorInput.addEventListener("input", () => {
    const val = authorInput.value.toLowerCase();
    const matches = authors.filter(a => a.toLowerCase().includes(val)).slice(0, 10);
    if (!val || matches.length === 0) {
      authorSuggestions.style.display = "none";
      updateAuthorButtonColor();
      return;
    }
    authorSuggestions.innerHTML = matches
      .map(a => `<div style="padding:0.4rem;cursor:pointer;">${a}</div>`)
      .join("");
    authorSuggestions.style.display = "block";

    authorSuggestions.querySelectorAll("div").forEach(div => {
      div.addEventListener("click", () => {
        authorInput.value = div.textContent;
        authorSuggestions.style.display = "none";
        updateAuthorButtonColor();
      });
    });
  });

  authorEnter.addEventListener("click", () => {
    updateAuthorButtonColor();
    popup.style.display = "none";
  });

  authorClear.addEventListener("click", () => {
    authorInput.value = "";
    authorSuggestions.style.display = "none";
    updateAuthorButtonColor();
  });

  
  // Click outside — close popup, block other clicks except .menu-btns
document.addEventListener("click", e => {
  const clickedInsidePopup = popup.contains(e.target);
  const clickedAuthorBtn = authorBtn.contains(e.target);
  const clickedMenuBtn = e.target.closest(".results-top"); // allow clicks on any menu button

  if (popup.style.display === "block" && !clickedInsidePopup && !clickedAuthorBtn) {
    popup.style.display = "none";
    updateAuthorButtonColor();

    // If not a .menu-btn click, block it
    if (!clickedMenuBtn) {
      e.stopPropagation();
      e.preventDefault();
    }
  }
});

  
  

  window.addEventListener("scroll", () => { if (popup.style.display === "block") positionPopup(); });
  window.addEventListener("resize", () => { if (popup.style.display === "block") positionPopup(); });
}); 
</script>


  
  <script>
    
    
document.addEventListener("DOMContentLoaded", () => {
  const fieldBtn = document.querySelector('#fields-button-one');
  if (!fieldBtn) return;

  const popup = document.createElement("div");
  popup.id = "dropdown-4";
  popup.className = "dropdown";
  Object.assign(popup.style, {
    padding: "0.75rem",
    position: "absolute",
    display: "none",
    background: "white",
    border: "1px solid #ccc",
    borderRadius: "10px",
    boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
    zIndex: "2000",
  });

  popup.innerHTML = `
    <input
      type="text"
      id="fieldInput"
      placeholder="Type field name..."
      style="width:100%;padding:0.5rem;border:1px solid #ccc;border-radius:6px;"
    />
    <div id="fieldSuggestions" style="
      border:1px solid #eee;
      border-radius:6px;
      margin-top:0.5rem;
      max-height:120px;
      overflow-y:auto;
      display:none;
    "></div>
    <div style="margin-top:0.75rem;text-align:right;">
      <button id="fieldEnter" style="
      
        background:#007bff;
        color:white;
        border:none;
        padding:0.4rem 0.8rem;
        border-radius:6px;
        cursor:pointer;
        margin-right:0.5rem;
      ">Enter</button>
      <button id="fieldClear" style="
      
        background:#eee;
        border:none;
        padding:0.4rem 0.8rem;
        border-radius:6px;
        cursor:pointer;
      ">Clear</button>
    </div>
  `;
  document.body.appendChild(popup);

  const fieldInput = popup.querySelector("#fieldInput");
  const fieldSuggestions = popup.querySelector("#fieldSuggestions");
  const fieldEnter = popup.querySelector("#fieldEnter");
  const fieldClear = popup.querySelector("#fieldClear");

  const fields = (typeof departments !== "undefined")
    ? [...departments] : [];

  
  function positionPopup() {
  const rect = fieldBtn.getBoundingClientRect();
  const popupWidth = popup.offsetWidth || 250; // fallback width before render
  const margin = 8; // small padding from edge

  // Base position: below button, left-aligned
  let top = rect.bottom + window.scrollY;
  let left = rect.left + window.scrollX;

  // Compute if it would overflow right edge
  const viewportWidth = window.innerWidth;
  const popupRightEdge = left + popupWidth;

  if (popupRightEdge + margin > viewportWidth) {
    // Shift so right edge aligns with viewport right edge
    left = viewportWidth - popupWidth - margin;
  }

  popup.style.top = `${top}px`;
  popup.style.left = `${Math.max(left, margin)}px`; // prevent going off left side
}


  function updateFieldButtonColor() {
    const hasField = fieldInput.value.trim().length > 0;
    fieldBtn.style.color = hasField ? "black" : "lightgray";
  }


function showSuggestions(list) {
  fieldSuggestions.innerHTML = list
    .map(a => `<div style="padding:0.4rem;cursor:pointer;">${a}</div>`)
    .join("");
  fieldSuggestions.style.display = "block";

  fieldSuggestions.querySelectorAll("div").forEach(div => {
    div.addEventListener("click", () => {
      fieldInput.value = div.textContent;
      fieldSuggestions.style.display = "none";
      updateFieldButtonColor();
    });
  });
}

let showFieldsFunc = function(){
    positionPopup();
      popup.style.display = "block";
      fieldInput.focus();
      showSuggestions(fields);
}

let showFields = function (){
    
    const visible = popup.style.display === "block";
    document.querySelectorAll(".dropdown").forEach(d => d.style.display = "none");
    if (!visible) {
      showFieldsFunc();

    } else {
      popup.style.display = "none";
      updateFieldButtonColor();
    }
}

  fieldBtn.addEventListener("click", e => {
    e.stopPropagation();
    showFields();
  });

  
  fieldInput.addEventListener("input", () => {
  const val = fieldInput.value.toLowerCase();
  const matches = fields
    .filter(a => a.toLowerCase().includes(val))
    .slice(0, 10);
  showSuggestions(matches.length ? matches : fields.slice(0, 10));
});
 
  
  
  
  

    fieldEnter.addEventListener("click", () => {
    updateFieldButtonColor();
    popup.style.display = "none";

    const selectedField = fieldInput.value.trim().toLowerCase();
    
    
    console.log(selectedField)
    documents.forEach(x=>
        
        
        console.log(x.field)
        );
    flatResults = selectedField
      ? documents.filter(doc => (doc.field || "").toLowerCase().includes(selectedField))
      : documents.map(doc => ({ ...doc }));

 //  if (typeof renderPage === "function") {
        
        
      currentPage = 1;
      renderPage(currentPage);
//   }
  });


  
  fieldClear.addEventListener("click", () => {
    fieldInput.value = "";
   // fieldSuggestions.style.display = "none";
    updateFieldButtonColor();
    
    showFieldsFunc();

    flatResults = documents.map(doc => ({ ...doc }));
  //  if (typeof renderPage === "function") {
  
  console.log(flatResults)
      currentPage = 1;
      renderPage(currentPage);
  //  }
  });


  
  document.addEventListener("click", e => {
  const clickedInsidePopup = popup.contains(e.target);
  const clickedFieldBtn = fieldBtn.contains(e.target);
  const clickedMenuBtn = e.target.closest(".results-top"); // any .menu-btn element

  if (popup.style.display === "block" && !clickedInsidePopup && !clickedFieldBtn) {
    popup.style.display = "none";
    updateFieldButtonColor();

    // If it's not one of the allowed .menu-btn buttons, block the click
    if (!clickedMenuBtn) {
      e.stopPropagation();
      e.preventDefault();
    }
  }
});

  
  
  
  

  window.addEventListener("scroll", () => { if (popup.style.display === "block") positionPopup(); });
  window.addEventListener("resize", () => { if (popup.style.display === "block") positionPopup(); });
}); 
</script>

  

</body>
</html>
